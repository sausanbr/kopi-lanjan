"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInline = isInline;
exports.isBlock = isBlock;
exports.isText = isText;
exports.isEmptyParagraph = isEmptyParagraph;
exports.stripEmptyTrailingParagraphFromDocument = stripEmptyTrailingParagraphFromDocument;
var blocks_1 = require("./blocks");
var inlines_1 = require("./inlines");
/**
 * Tiny replacement for Object.values(object).includes(key) to
 * avoid including CoreJS polyfills
 */
function hasValue(obj, value) {
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        if (value === obj[key]) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if the node is an instance of Inline.
 */
function isInline(node) {
    return hasValue(inlines_1.INLINES, node.nodeType);
}
/**
 * Checks if the node is an instance of Block.
 */
function isBlock(node) {
    return hasValue(blocks_1.BLOCKS, node.nodeType);
}
/**
 * Checks if the node is an instance of Text.
 */
function isText(node) {
    return node.nodeType === 'text';
}
/**
 * Checks if a paragraph is empty (has only one child and that child is an empty string text node)
 */
function isEmptyParagraph(node) {
    if (node.nodeType !== blocks_1.BLOCKS.PARAGRAPH) {
        return false;
    }
    if (node.content.length !== 1) {
        return false;
    }
    var textNode = node.content[0];
    return textNode.nodeType === 'text' && textNode.value === '';
}
function isValidDocument(document) {
    return (document != null &&
        typeof document === 'object' &&
        'content' in document &&
        Array.isArray(document.content));
}
var MIN_NODES_FOR_STRIPPING = 2;
/**
 * Strips empty trailing paragraph from a document if enabled
 * @param document - The rich text document to process
 * @returns A new document with the empty trailing paragraph removed (if conditions are met)
 * @example
 * const processedDoc = stripEmptyTrailingParagraphFromDocument(document);
 */
function stripEmptyTrailingParagraphFromDocument(document) {
    if (!isValidDocument(document) || document.content.length < MIN_NODES_FOR_STRIPPING) {
        return document;
    }
    var lastNode = document.content[document.content.length - 1];
    // Check if the last node is an empty paragraph
    if (isEmptyParagraph(lastNode)) {
        return __assign(__assign({}, document), { content: document.content.slice(0, -1) });
    }
    return document;
}
//# sourceMappingURL=helpers.js.map